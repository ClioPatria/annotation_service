:- module(oa_annotation, [
			  rdf_add_annotation/2,
			  rdf_get_annotation/2,
			  rdf_get_annotation_by_target/3,
			  rdf_remove_annotation/2,
			  rdf_has_graph/4
			 ]).
/** <module> Open Annotation Prolog API

Some simple predicates to create, get and remove open annotation
triples. Since OA is a bit of a moving target, this may not be
completely following the spec... Especially not when dealing with
literal body tags.

@author Jacco van Ossenbruggen
@license LGPL
*/
:- use_module(library(semweb/rdf_db)).
:- use_module(library(semweb/rdf_label)).
:- use_module(library(oa_schema)).
:- use_module(library(graph_version)).

:- rdf_meta
	rdf_has_graph(r,r,r,r).


%%	rdf_add_annotation(+Options:list, -Annotation:url) is det.
%
%	Creates an object of type oa:'Annotation' with uri Annotation
%	from options passed in Options. The required options are:
%       * target(Target)
%         uri of the target
%       * body(Body)
%         literal(tag) or uri of the body
%
%       Optional are:
%	* user(User)
%         defaults to user:anonymous
%	* label(Label)
%         defaults to the body label
%	* field(Field)
%	  defaults to dc:subject
%	* type(Type)
%	  defaults to oax:Tag
%	* typingTime
%         default to 0 (zero)
%	* timestamp(T)
%         defaults to the current time in xsd:dateTime notation
%
%
%	The uri of Annotation is generated by first creating the
%	sha1 hash of the sorted list of predicate/object pairs making
%	up the annotation, and then passing this hash to gv_hash_uri/2
%	to create the final uri.
%
%       Note that if no
%	timestamp is given, each call to this predicate with the same
%	parameters will intentionally yield a new annotation with a new
%	uri (because the changing current time will be part of the hash
%	that is used to create the uri of Annotation).

rdf_add_annotation(Options, Annotation) :-
	option(target(Target), Options),
	option(body(Body),     Options),

	option(user(User),      Options, user:anonymous),
	option(field(Field),    Options, dcterms:subject),
	option(typing_time(TT),	Options, 0),
	option(graph(Graph),    Options, 'annotations'),
	(   option(type(Type), Options)
	->  (  uri_is_global(Type)
	    ->	QType = Type
	    ;	QType = an:Type
	    )
	;   QType = oax:'Tag'
	),

	(   rdf_is_literal(Body)
	->  literal_text(Body, DefaultLabel)
	;   rdf_label(Body, DefaultLabel)
	),
	option(label(Label),    Options, DefaultLabel),

	get_time(T),
	format_time(atom(DefaultTimeStamp), '%FT%T%:z', T), % xsd:dateTime
	option(timestamp(TimeStamp), Options, DefaultTimeStamp),
	KeyValue0 = [
		     po(rdf:type, oa:'Annotation'),
		     po(rdf:type, QType),
		     po(oa:annotated, literal(type(xsd:dateTime, TimeStamp))),
		     po(oa:annotator, User),
		     po(oa:hasTarget, Target),
		     po(oa:hasBody, Body),
		     po(dcterms:title, literal(Label)),
		     po(an:annotationField, Field),
		     po(an:typingTime, literal(type(xsd:integer, TT)))
		    ],
	sort(KeyValue0, KeyValue),
	rdf_global_term(KeyValue, Pairs),
	variant_sha1(Pairs, Hash),
	gv_hash_uri(Hash, Annotation),
	maplist(po2rdf(Annotation),Pairs,Triples),
	gv_graph_triples(Graph, Triples).

po2rdf(S,po(P,O),rdf(S,P,O)).

%%	rdf_get_annotation(+Annotation:url, -Props:list) is det.
%
%	Unifies the predicate/object pairs of Annotation with
%	Props (using option list notation).

rdf_get_annotation(Annotation, Props) :-
	get_annotation_properties(Annotation, _Graph, Props).

%%	rdf_get_annotation_by_target(+Target:uri, +Graph:uri,-Props:list) is nondet.
%
%	Props is an option list with the properties of Annotation
%	in Graph.
%
%	Hack:- You can filter on annotationField(F), user(U) by putting
%	these in the Props as the first two properties...

rdf_get_annotation_by_target(Target, Graph, Props) :-
	rdf(Annotation, oa:hasTarget, Target, Graph),
	get_annotation_properties(Annotation, Graph, Props).

get_annotation_properties(Annotation, Graph, Props) :-
	rdf(Annotation, oa:hasTarget, Target, Graph),
	rdf(Annotation, an:annotationField, Field, Graph),
	rdf_has_graph(Annotation, oa:annotator, User, Graph),
	rdf_has_graph(Annotation, oa:hasBody, Body, Graph),
	rdf_has_graph(Annotation, dcterms:title, Lit, Graph),
	literal_text(Lit, Label),
	rdf(Annotation, rdf:type, Type, Graph),
	rdf_global_id(an:LocalType, Type),
	Props = [
		 % these two first, sorry!
		 annotationField(Field),
		 user(User),

		 % then the rest...
		 target(Target),
		 annotation(Annotation),
		 label(Label),
		 body(Body),
		 type(LocalType)
	].

%%	rdf_remove_annotation(+Annotation:url, ?Target:url) is det.
%
%	Removes Annotation on Target. Also succeeds if Annotation
%	does not exists.

rdf_remove_annotation(Annotation, Target) :-
	(   rdf(Annotation, oa:hasTarget, Target, Target)
	->  rdf_retractall(Annotation, _, _, Target)
	;   true
	).

%%	rdf_has_graph(Subject, SuperProperty, Object, Graph) is nondet.
%
%	True if rdf(Subject, Property, Object, Graph) with
%       Property being an rdfs:subPropertyOf SuperProperty.

rdf_has_graph(S,P,O,G) :-
	rdf_graph(G),
	rdf_has(S,P,O,RP),
	rdf(S,RP,O,G).
